import {isValid, deepCopy} from "./Heuristics/GenericFunctions"export default function greedySudokuSolver(data, animation) {        //create an array with all the empty cells    let possibleCell = []    for (let i = 0; i < 9; i++) {        for (let j = 0; j < 9; j++) {            if (data[i][j] === 0){                possibleCell.push([i,j])            }        }    }    // base-case : if there is no cells to fill, we're done -> return true !    if (possibleCell.length === 0){        return true    }    //Determine which cell is the "Best" (the one with the smallest number of candidates)    let bestCell = [-1,-1]    let min = 9    for (let idx = 0; idx<possibleCell.length; idx++){        let i = possibleCell[idx][0]        let j = possibleCell[idx][1]        let count = 0        for (let number = 1; number<10; number++){            if (isValid(data, i, j, number)){                count++            }        }        if(count<min){            bestCell = [i,j]            min = count        }    }    //Start to backtrack with the best cell, that we have just identified    let i = bestCell[0]    let j = bestCell[1]    for (let number = 1; number<10; number++){        if (isValid(data, i, j, number)){            data[i][j] = number;            let newData = deepCopy(data)            animation.push(newData)            if (greedySudokuSolver(data, animation)) {                return true;            } else {                data[i][j] = 0;                let newData = deepCopy(data)                animation.push(newData)            }        }    }    // if we come here, it means that we cannot solve the current Sudoku -> return false!     return false                }